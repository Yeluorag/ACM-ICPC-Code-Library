/*
购买某个物品时，必须先买其对应的箱子。求最大价值。
其实这是一种树形DP，因为对每个父节点都要更新其儿子值。
对第i组数据，先存储其买当前盒子的值，然后对这个组做01背包，
这个当然是用这一组盒子的最优数据。做完01背包之后，
再与i-1组比较，前面做的操作都是用这组盒子产生的最优值，
那么与dp[i-1]，dp[i-1]显然是没有用第i组盒子的最优值，
所以其实就是用box[i]和不用box[i]，这一次比较复杂度为O(w)。
*/
mem(dp, -1);  
mem(dp[0], 0);  
FOR(i, 1, n) {  
    sii(p, m);  
    FOR(j, p, w) dp[i][j] = dp[i-1][j-p];  
    rep(j, m) {  
        sii(c, v);  
        for(int k = w; k >= c; k --)   
            if(dp[i][k-c] > -1)   
                Max(dp[i][k], dp[i][k-c] + v);  
    }  
    FOR(j, 0, w) Max(dp[i][j], dp[i-1][j]);  
}  